"use client";
import React, {useState} from "react";

import _ from "lodash";

import {useApolloClient} from "@apollo/client";
import {isNonEmptyArray} from "@apollo/client/utilities";
import {
  Add,
  AddTask,
  Send,
} from "@mui/icons-material";
import {
  IconButton,
  Paper,
  Stack,
  Tooltip,
  Typography,
  useTheme,
} from "@mui/material";
import Grid from "@mui/material/Unstable_Grid2";
import {getGoalFlatQueryDoc} from "@reasonote/lib-sdk-apollo-client";
import {
  OrderByDirection,
} from "@reasonote/lib-sdk-apollo-client/src/codegen/codegen-generic-client/graphql";
import {
  notEmpty,
  typedUuidV4,
} from "@reasonote/lib-utils";

import {useRsnUser} from "../../../../clientOnly/hooks/useRsnUser";
import {
  BotMessage,
} from "../../../../components/chat/Messages/BotMessage/BotMessage";
import {UserMessage} from "../../../../components/chat/Messages/UserMessage";
import {useSupabase} from "../../../../components/supabase/SupabaseProvider";
import {
  JournalDigDeeperRoute,
} from "../../../api/journal/dig-deeper/routeSchema";
import {SuggestedGoal} from "../_common/interfaces/suggestedGoals";
import {EditorTextField2} from "./EditorTextField2";

// The same as the MessageWithAuthor type, but the author can be undefined
type MessageWithOptionalAuthor = {
  id: string;
  content: string;
  role: "user" | "assistant" | "system" | "function";
  author?: {
    id: string;
    description: string;
    name: string;
    prompt: string;
    avatarUrl: string;
  };
  /**
   * If present, this message is a function call.
   */
  function_call?: {
    /**
     *
     */
    name: string;
    /**
     * JSON-encoded arguments, as generated by the model.
     */
    arguments?: string;
  };
};

type MessageWithType = MessageWithOptionalAuthor & { type: "message" };

export type ChatEvent =
  | MessageWithType
  | { type: "suggest-goals"; goalSuggestions: SuggestedGoal[] }
  | { type: "enter"; authorName: string }
  | { type: "leave"; authorName: string }
  | { type: "bot-interrupted"; cause?: string };

function isMessageWithType(m: ChatEvent): m is MessageWithType {
  return m.type === "message";
}

export default function GoalChat({
  goalSessionId,
  chatHistory,
  setChatHistory,
  onGoalAdded,
}: {
  goalSessionId: string;
  chatHistory: ChatEvent[];
  setChatHistory: (f: (old: ChatEvent[]) => ChatEvent[]) => void;
  onGoalAdded: (goal: SuggestedGoal) => void;
}) {
  const theme = useTheme();
  const ac = useApolloClient();
  const sb = useSupabase();
  const { rsnUserId } = useRsnUser();
  const [messageText, setMessageText] = useState<string>(
    "How should I make my day more efficient?"
  );
  const [chatModel, setChatModel] = useState<
    { type: 'openai', modelName: string}
  >({ type: "openai", modelName: "gpt-4" });
  const [waitingForBot, setWaitingForBot] = useState<boolean>(false);

  const [goalsAdded, setGoalsAdded] = useState<SuggestedGoal[]>([]);

  const _onGoalAdded = (goal: SuggestedGoal) => {
    onGoalAdded(goal);
    setGoalsAdded((old) => [...old, goal]);
  };

  const sendMessage = async (
    newMessageText: string,
    chatHistoryAtSendTime: ChatEvent[]
  ) => {
    if (newMessageText.trim().length === 0) {
      return;
    }
    setWaitingForBot(true);

    try {
      // Clear the message text.
      setMessageText("");

      const newChatMessage = {
        type: "message" as const,
        id: typedUuidV4("rsnmsg"),
        role: "user" as const,
        content: newMessageText,
      };

      const newChatHistory = [...chatHistoryAtSendTime, newChatMessage];

      // Add the user message to the chat history.
      setChatHistory((old) => {
        return [...old, newChatMessage];
      });

      // Create an optimistic id for the response.
      const responseRsnMsgId = typedUuidV4("rsnmsg");

      if (newChatHistory.length < 1) {
        return;
      }

      const pastJournalEntries = newChatHistory
        .map((m) => {
          if (isMessageWithType(m)) {
            return {
              type:
                m.role === "assistant" ? ("ai" as const) : ("human" as const),
              content: m.content,
            };
          }
        })
        .filter(notEmpty);

      if (isNonEmptyArray(pastJournalEntries) === false) {
        return;
      }

      //@ts-ignore
      function notEmptyArr<T>(arr: T[]): arr is [T, ...T] {
        return arr.length >= 1;
      }

      if (notEmptyArr(pastJournalEntries)) {
        const { data: goals } = await ac.query({
          query: getGoalFlatQueryDoc,
          variables: {
            filter: {
              createdBy: { eq: rsnUserId },
            },
            orderBy: {
              createdDate: OrderByDirection.AscNullsLast,
            },
            first: 10,
          },
        });

        const answer = await JournalDigDeeperRoute.call({
          sessionGoals:
            goals?.goalCollection?.edges?.map((g) => g.node.name) ?? [],
          pastJournalEntries,
          driverConfig: {
            type: "openai",
            config: {
              model: chatModel?.modelName!,
            },
          },
        });

        console.log("answer", answer);

        // Add message to chat history.
        setChatHistory((old) => {
          return [
            ...old,
            {
              type: "message" as const,
              id: typedUuidV4("rsnmsg"),
              role: "assistant" as const,
              content: answer.data?.newMessage.content ?? "",
            },
            answer.data?.goalsUserMentioned &&
            answer.data?.goalsUserMentioned.length > 0
              ? {
                  type: "suggest-goals" as const,
                  goalSuggestions:
                    answer.data?.goalsUserMentioned.map((goal) => {
                      return {
                        goalName: goal.name,
                        goalType: goal.type,
                      };
                    }) ?? [],
                }
              : null,
          ].filter(notEmpty);
        });
      }
    } finally {
      setWaitingForBot(false);
    }
  };

  const onKeyUp = (
    ev: React.KeyboardEvent<HTMLDivElement | HTMLTextAreaElement>
  ) => {
    if (ev.key === "Enter") {
      sendMessage(messageText, chatHistory);
    }
  };

  return (
    <Grid
      container
      gap={1}
      height="100%"
      // sx={{ overscrollBehavior: "contain" }}
    >
      {chatHistory.length ? (
        <Grid xs={12} maxHeight={"70%"} overflow="scroll">
          <div
            style={{
              width: "100%",
              flex: 1,
              overflowY: "auto",
            }}
          >
            <Stack
              boxSizing="border-box"
              justifyContent="center"
              gap="10px"
              alignContent="center"
              flexDirection={"column"}
              width={"100%"}
              sx={{ overFlowX: "none" }}
              padding={"4px"}
            >
              {chatHistory.map((msg, i) => {
                if (isMessageWithType(msg)) {
                  return msg.role === "user" ? (
                    <UserMessage key={`msg-${i}`} msg={msg} />
                  ) : (
                    <BotMessage
                      key={`msg-${i}`}
                      reactions={[]}
                      isEditingAuthor={false}
                      isAuthorStillInChat={true}
                      msg={msg}
                      i={i}
                      disableEditing
                      setEditingAuthorId={() => null}
                    />
                  );
                } else if (msg.type === "bot-interrupted") {
                  return (
                    <Stack
                      key={`msg-${i}`}
                      justifyContent="center"
                      alignContent={"center"}
                      alignItems={"center"}
                      flexDirection="row"
                      gap={2}
                      height={"max-content"}
                    >
                      <Typography
                        color={theme.palette.grey[600]}
                        fontStyle={"italic"}
                      >
                        {msg.cause ? msg.cause : "Bot interrupted."}
                      </Typography>
                    </Stack>
                  );
                } else if (msg.type === "suggest-goals") {
                  return (
                    <Stack
                      key={`msg-${i}`}
                      justifyContent="center"
                      alignContent={"start"}
                      alignItems={"end"}
                      flexDirection="column"
                      gap={2}
                      height={"max-content"}
                      paddingLeft="10px"
                    >
                      {msg.goalSuggestions.map((suggestion, sIdx) => {
                        console.log("suggestion", suggestion);

                        console.log("goalsAdded", goalsAdded);
                        console.log("suggestion.goalName", suggestion.goalName);

                        const goalAdded = !!goalsAdded.find(
                          (g) => g.goalName === suggestion.goalName
                        );

                        return (
                          <Paper
                            sx={{ padding: "5px", backgroundColor: "primary" }}
                          >
                            <Stack
                              key={`stuff-${sIdx}`}
                              direction={"row"}
                              alignItems={"center"}
                              gap={1}
                            >
                              <Typography
                                color={
                                  goalAdded
                                    ? theme.palette.grey[600]
                                    : theme.palette.grey[300]
                                }
                              >
                                {suggestion.goalName}
                              </Typography>

                              {/* Checkbox to accept this new goal */}
                              <IconButton
                                size="small"
                                sx={{
                                  color: goalAdded
                                    ? theme.palette.grey[600]
                                    : theme.palette.grey[300],
                                }}
                                onClick={() => {
                                  _onGoalAdded(suggestion);
                                }}
                              >
                                {goalAdded ? (
                                  <AddTask />
                                ) : (
                                  <Add color={"primary"} />
                                )}
                              </IconButton>
                            </Stack>
                          </Paper>
                        );
                      })}
                    </Stack>
                  );
                }
              })}
              {/* Skeleton loader if waiting for bot */}
              {waitingForBot ? (
                <Stack
                  justifyContent="center"
                  alignContent={"center"}
                  alignItems={"center"}
                  flexDirection="row"
                  gap={2}
                  height={"max-content"}
                >
                  <Typography
                    color={theme.palette.grey[600]}
                    fontStyle={"italic"}
                  >
                    Bot is typing...
                  </Typography>
                </Stack>
              ) : null}
            </Stack>
          </div>
        </Grid>
      ) : null}
      <Grid container xs={12}>
        <div
          style={{
            display: "grid",
            gridAutoFlow: "column",
            gap: "10px",
            width: "100%",
            gridTemplateColumns: "1fr auto",
          }}
        >
          <Grid container>
            {/* <TextField
                        id="outlined-basic"
                        fullWidth
                        multiline={true}
                        label=""
                        variant="outlined"
                        value={messageText}
                        onChange={(ev) => setMessageText(ev.target.value)}
                        onKeyUp={onKeyUp}
                    /> */}

            <EditorTextField2
              value={messageText}
              onChange={(ev) => setMessageText(ev.target.value)}
              onKeyUp={(ev) => onKeyUp(ev)}
              sx={{
                width: "100%",
              }}
            />
          </Grid>
          <Grid
            container
            alignItems={"center"}
            justifyItems={"center"}
            alignContent={"center"}
            justifyContent={"center"}
            width="min-content"
          >
            <Tooltip title={"Send"} placement={"top"}>
              <span>
                <IconButton
                  onClick={() => sendMessage(messageText, chatHistory)}
                  centerRipple
                  color={"primary"}
                  disabled={messageText.trim().length === 0}
                >
                  <Send />
                </IconButton>
              </span>
            </Tooltip>
          </Grid>
        </div>
      </Grid>
    </Grid>
  );
}
